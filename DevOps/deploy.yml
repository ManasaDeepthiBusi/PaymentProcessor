# Single deploy pipeline with four stages: Dev -> QA -> Staging -> Prod
# Deploys to AWS using ECR + App Runner. Configure AWS variables below.

trigger:
  branches:
    include:
      - main

variables:
  # Build settings
  - name: buildConfiguration
    value: 'Release'

  # AWS settings (set secrets in pipeline/variable group)
  - name: awsRegion
    value: 'us-east-1'                # override per your region
  - name: ecrRepoName
    value: 'paymentprocessor-api'     # ECR repository name to push images to
  - name: containerPort
    value: '8080'                     # Container port exposed by the API image
  - name: imageTag
    value: '$(Build.BuildId)'         # Image tag to push/deploy

  # App Runner service identifiers per env (provide Service ARN or Name)
  - name: appRunnerServiceArnDev
    value: 'arn:aws:apprunner:us-east-1:123456789012:service/paymentprocessor-dev/xxxxxxxxxxxx'   # TODO replace
  - name: appRunnerServiceArnQa
    value: 'arn:aws:apprunner:us-east-1:123456789012:service/paymentprocessor-qa/xxxxxxxxxxxx'    # TODO replace
  - name: appRunnerServiceArnStaging
    value: 'arn:aws:apprunner:us-east-1:123456789012:service/paymentprocessor-staging/xxxxxxxxxx' # TODO replace
  - name: appRunnerServiceArnProd
    value: 'arn:aws:apprunner:us-east-1:123456789012:service/paymentprocessor-prod/xxxxxxxxxxxxx' # TODO replace

  # App Runner needs an access role to pull from ECR (assume created ahead of time).
  - name: appRunnerAccessRoleArn
    value: 'arn:aws:iam::123456789012:role/apprunner-ecr-access-role'  # TODO replace

pool:
  vmImage: 'ubuntu-latest'

stages:
- stage: Dev
  displayName: 'Deploy to Dev'
  jobs:
  - deployment: DeployToDev
    displayName: 'Deploy to Dev'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Install prerequisites (Docker + AWS CLI)
          - script: |
              sudo apt-get update
              sudo apt-get install -y docker.io jq awscli
              sudo usermod -aG docker $(whoami)
            displayName: 'Install Docker and AWS CLI'

          # Ensure Docker is available in current session
          - script: |
              docker --version
              aws --version
            displayName: 'Verify Docker and AWS CLI'

          # Authenticate to AWS via environment variables (set these as pipeline secrets)
          - script: |
              echo "Using AWS region: $(awsRegion)"
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              echo "AWS Account: ${ACCOUNT_ID}"
              echo "##vso[task.setvariable variable=AccountId]${ACCOUNT_ID}"
            displayName: 'Get AWS account ID'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Create ECR repository if it does not exist
          - script: |
              set -e
              aws ecr describe-repositories --repository-names $(ecrRepoName) >/dev/null 2>&1 || \
                aws ecr create-repository --repository-names $(ecrRepoName)
            displayName: 'Ensure ECR repository exists'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Login to ECR
          - script: |
              ECR_URI=$(AccountId).dkr.ecr.$(awsRegion).amazonaws.com
              aws ecr get-login-password --region $(awsRegion) | docker login --username AWS --password-stdin ${ECR_URI}
              echo "##vso[task.setvariable variable=EcrUri]${ECR_URI}"
            displayName: 'Docker login to ECR'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Build and push Docker image
          - script: |
              IMAGE=$(EcrUri)/$(ecrRepoName):$(imageTag)
              echo "Building image ${IMAGE}"
              docker build -f PaymentProcessor.Api/Dockerfile -t ${IMAGE} .
              docker push ${IMAGE}
              echo "##vso[task.setvariable variable=ImageUri]${IMAGE}"
            displayName: 'Build and push API image'

          # Build env var list from JSON and update App Runner (Dev)
          - script: |
              set -e
              PARAMS_FILE="Deployment/Transforms/Dev/parameters.json"
              echo "Loading parameters from ${PARAMS_FILE}"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              # Append ASPNETCORE_URLS
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              # Compose source configuration file
              cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "$(ImageUri)",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "$(appRunnerAccessRoleArn)"
                }
              }
              EOF
              aws apprunner update-service --service-arn $(appRunnerServiceArnDev) --source-configuration file://source-config.json
            displayName: 'Update App Runner service (Dev)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: QA
  displayName: 'Deploy to QA'
  dependsOn: Dev
  condition: succeeded()
  jobs:
  - deployment: DeployToQa
    displayName: 'Deploy to QA'
    environment: 'qa'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          # Install AWS CLI and jq (if not present), compute image and update QA service
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq awscli
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              echo "##vso[task.setvariable variable=AccountId]${ACCOUNT_ID}"
              IMAGE=$(AccountId).dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              echo "Using image ${IMAGE}"
              PARAMS_FILE="Deployment/Transforms/QA/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "$(appRunnerAccessRoleArn)"
                }
              }
              EOF
              aws apprunner update-service --service-arn $(appRunnerServiceArnQa) --source-configuration file://source-config.json
            displayName: 'Update App Runner service (QA)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: Staging
  displayName: 'Deploy to Staging'
  dependsOn: QA
  condition: succeeded()
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging'
    environment: 'staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq awscli
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              IMAGE=${ACCOUNT_ID}.dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              PARAMS_FILE="Deployment/Transforms/BETA/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "$(appRunnerAccessRoleArn)"
                }
              }
              EOF
              aws apprunner update-service --service-arn $(appRunnerServiceArnStaging) --source-configuration file://source-config.json
            displayName: 'Update App Runner service (Staging/Beta)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: Prod
  displayName: 'Deploy to Prod'
  dependsOn: Staging
  condition: succeeded()
  jobs:
  - deployment: DeployToProd
    displayName: 'Deploy to Prod'
    environment: 'prod'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq awscli
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              IMAGE=${ACCOUNT_ID}.dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              PARAMS_FILE="Deployment/Transforms/Prod/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "$(appRunnerAccessRoleArn)"
                }
              }
              EOF
              aws apprunner update-service --service-arn $(appRunnerServiceArnProd) --source-configuration file://source-config.json
            displayName: 'Update App Runner service (Prod)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

# Notes:
# - Set pipeline variables or variable group secrets for AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Do not commit secrets.
# - Provide the App Runner Service ARNs per environment and an Access Role ARN with ECR pull permissions for App Runner.
# - This pipeline builds a Docker image from PaymentProcessor.Api/Dockerfile, pushes to ECR, and updates App Runner to the new image.
# - Ensure the Azure DevOps agent has permissions to run Docker (ubuntu-latest hosted agent is used). If using a self-hosted agent, install Docker and AWS CLI.
