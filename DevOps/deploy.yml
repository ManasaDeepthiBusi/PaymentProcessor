# Single deploy pipeline with four stages: Dev -> QA -> Staging -> Prod
# Deploys to AWS using ECR + App Runner. Configure AWS variables below.

trigger:
  branches:
    include:
      - main

variables:
  # Link to variable group containing AWS credentials
  - group: DeploymentVariables

  # Build settings
  - name: buildConfiguration
    value: 'Release'

  # AWS settings (set secrets in pipeline/variable group)
  - name: awsRegion
    value: 'us-east-1'                # override per your region
  - name: ecrRepoName
    value: 'paymentprocessor-api'     # ECR repository name to push images to
  - name: containerPort
    value: '8080'                     # Container port exposed by the API image
  - name: imageTag
    value: '$(Build.BuildId)'         # Image tag to push/deploy

  # App Runner service names per env (will be auto-created if they don't exist)
  - name: appRunnerServiceNameDev
    value: 'paymentprocessor-dev'
  - name: appRunnerServiceNameQa
    value: 'paymentprocessor-qa'
  - name: appRunnerServiceNameStaging
    value: 'paymentprocessor-staging'
  - name: appRunnerServiceNameProd
    value: 'paymentprocessor-prod'

  # App Runner needs an access role to pull from ECR. Pipeline will create this if it doesn't exist.
  - name: appRunnerAccessRoleName
    value: 'AppRunnerECRAccessRole'

pool:
  vmImage: 'ubuntu-latest'

stages:
- stage: Dev
  displayName: 'Deploy to Dev'
  jobs:
  - deployment: DeployToDev
    displayName: 'Deploy to Dev'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Install prerequisites (Docker + AWS CLI)
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq unzip
              # Install/Update AWS CLI v2
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install --update
            displayName: 'Install Docker and AWS CLI'

          # Verify AWS CLI installation
          - script: |
              aws --version
            displayName: 'Verify AWS CLI'

          # Authenticate to AWS via environment variables (set these as pipeline secrets)
          - script: |
              echo "Using AWS region: $(awsRegion)"
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              echo "AWS Account: ${ACCOUNT_ID}"
              echo "##vso[task.setvariable variable=AccountId]${ACCOUNT_ID}"
            displayName: 'Get AWS account ID'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Create ECR repository if it does not exist
          - script: |
              set -e
              aws ecr describe-repositories --repository-name $(ecrRepoName) >/dev/null 2>&1 || \
                aws ecr create-repository --repository-name $(ecrRepoName)
            displayName: 'Ensure ECR repository exists'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Login to ECR
          - script: |
              ECR_URI=$(AccountId).dkr.ecr.$(awsRegion).amazonaws.com
              aws ecr get-login-password --region $(awsRegion) | docker login --username AWS --password-stdin ${ECR_URI}
              echo "##vso[task.setvariable variable=EcrUri]${ECR_URI}"
            displayName: 'Docker login to ECR'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Build and push Docker image
          - script: |
              IMAGE=$(EcrUri)/$(ecrRepoName):$(imageTag)
              echo "Building image ${IMAGE}"
              docker build -f PaymentProcessor.Api/Dockerfile -t ${IMAGE} .
              docker push ${IMAGE}
              echo "##vso[task.setvariable variable=ImageUri]${IMAGE}"
            displayName: 'Build and push API image'

          # Create IAM role for App Runner if it doesn't exist
          - script: |
              set -e
              ROLE_NAME="$(appRunnerAccessRoleName)"
              echo "Checking if IAM role ${ROLE_NAME} exists..."
              if ! aws iam get-role --role-name ${ROLE_NAME} >/dev/null 2>&1; then
                echo "Creating IAM role ${ROLE_NAME}..."
                cat > trust-policy.json <<EOF
              {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "build.apprunner.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              }
              EOF
                aws iam create-role --role-name ${ROLE_NAME} --assume-role-policy-document file://trust-policy.json
                aws iam attach-role-policy --role-name ${ROLE_NAME} --policy-arn arn:aws:iam::aws:policy/service-role/AWSAppRunnerServicePolicyForECRAccess
                echo "IAM role ${ROLE_NAME} created."
              else
                echo "IAM role ${ROLE_NAME} already exists."
              fi
              ROLE_ARN=$(aws iam get-role --role-name ${ROLE_NAME} --query 'Role.Arn' --output text)
              echo "##vso[task.setvariable variable=AppRunnerRoleArn]${ROLE_ARN}"
            displayName: 'Ensure App Runner IAM role exists'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # Create or update App Runner service (Dev)
          - script: |
              set -e
              SERVICE_NAME="$(appRunnerServiceNameDev)"
              PARAMS_FILE="Deployment/Transforms/Dev/parameters.json"
              echo "Loading parameters from ${PARAMS_FILE}"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              
              # Check if service exists
              if aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text | grep -q .; then
                echo "App Runner service ${SERVICE_NAME} exists. Updating..."
                SERVICE_ARN=$(aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)
                cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "$(ImageUri)",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "$(AppRunnerRoleArn)"
                }
              }
              EOF
                aws apprunner update-service --service-arn ${SERVICE_ARN} --source-configuration file://source-config.json
                echo "Service ${SERVICE_NAME} updated."
              else
                echo "App Runner service ${SERVICE_NAME} does not exist. Creating..."
                cat > create-service.json <<EOF
              {
                "ServiceName": "${SERVICE_NAME}",
                "SourceConfiguration": {
                  "ImageRepository": {
                    "ImageIdentifier": "$(ImageUri)",
                    "ImageRepositoryType": "ECR",
                    "ImageConfiguration": {
                      "Port": "$(containerPort)",
                      "RuntimeEnvironmentVariables": $ENV_ARR
                    }
                  },
                  "AuthenticationConfiguration": {
                    "AccessRoleArn": "$(AppRunnerRoleArn)"
                  },
                  "AutoDeploymentsEnabled": false
                },
                "InstanceConfiguration": {
                  "Cpu": "1024",
                  "Memory": "2048"
                }
              }
              EOF
                aws apprunner create-service --cli-input-json file://create-service.json --region $(awsRegion)
                echo "Service ${SERVICE_NAME} created. Waiting for it to become available..."
                aws apprunner wait service-running --service-name ${SERVICE_NAME} --region $(awsRegion) || true
              fi
            displayName: 'Create or update App Runner service (Dev)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: QA
  displayName: 'Deploy to QA'
  dependsOn: Dev
  condition: succeeded()
  jobs:
  - deployment: DeployToQa
    displayName: 'Deploy to QA'
    environment: 'qa'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          # Install AWS CLI and jq (if not present), compute image and update QA service
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq unzip
              # Install/Update AWS CLI v2
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install --update
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              SERVICE_NAME="$(appRunnerServiceNameQa)"
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              echo "##vso[task.setvariable variable=AccountId]${ACCOUNT_ID}"
              IMAGE=${ACCOUNT_ID}.dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              echo "Using image ${IMAGE}"
              PARAMS_FILE="Deployment/Transforms/QA/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              
              # Get IAM role ARN
              ROLE_ARN=$(aws iam get-role --role-name $(appRunnerAccessRoleName) --query 'Role.Arn' --output text)
              
              # Check if service exists
              if aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text | grep -q .; then
                echo "App Runner service ${SERVICE_NAME} exists. Updating..."
                SERVICE_ARN=$(aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)
                cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "${ROLE_ARN}"
                }
              }
              EOF
                aws apprunner update-service --service-arn ${SERVICE_ARN} --source-configuration file://source-config.json
              else
                echo "App Runner service ${SERVICE_NAME} does not exist. Creating..."
                cat > create-service.json <<EOF
              {
                "ServiceName": "${SERVICE_NAME}",
                "SourceConfiguration": {
                  "ImageRepository": {
                    "ImageIdentifier": "${IMAGE}",
                    "ImageRepositoryType": "ECR",
                    "ImageConfiguration": {
                      "Port": "$(containerPort)",
                      "RuntimeEnvironmentVariables": $ENV_ARR
                    }
                  },
                  "AuthenticationConfiguration": {
                    "AccessRoleArn": "${ROLE_ARN}"
                  },
                  "AutoDeploymentsEnabled": false
                },
                "InstanceConfiguration": {
                  "Cpu": "1024",
                  "Memory": "2048"
                }
              }
              EOF
                aws apprunner create-service --cli-input-json file://create-service.json --region $(awsRegion)
                echo "Service ${SERVICE_NAME} created."
              fi
            displayName: 'Create or update App Runner service (QA)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: Staging
  displayName: 'Deploy to Staging'
  dependsOn: QA
  condition: succeeded()
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging'
    environment: 'staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq unzip
              # Install/Update AWS CLI v2
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install --update
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              SERVICE_NAME="$(appRunnerServiceNameStaging)"
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              IMAGE=${ACCOUNT_ID}.dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              PARAMS_FILE="Deployment/Transforms/BETA/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              
              # Get IAM role ARN
              ROLE_ARN=$(aws iam get-role --role-name $(appRunnerAccessRoleName) --query 'Role.Arn' --output text)
              
              # Check if service exists
              if aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text | grep -q .; then
                echo "App Runner service ${SERVICE_NAME} exists. Updating..."
                SERVICE_ARN=$(aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)
                cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "${ROLE_ARN}"
                }
              }
              EOF
                aws apprunner update-service --service-arn ${SERVICE_ARN} --source-configuration file://source-config.json
              else
                echo "App Runner service ${SERVICE_NAME} does not exist. Creating..."
                cat > create-service.json <<EOF
              {
                "ServiceName": "${SERVICE_NAME}",
                "SourceConfiguration": {
                  "ImageRepository": {
                    "ImageIdentifier": "${IMAGE}",
                    "ImageRepositoryType": "ECR",
                    "ImageConfiguration": {
                      "Port": "$(containerPort)",
                      "RuntimeEnvironmentVariables": $ENV_ARR
                    }
                  },
                  "AuthenticationConfiguration": {
                    "AccessRoleArn": "${ROLE_ARN}"
                  },
                  "AutoDeploymentsEnabled": false
                },
                "InstanceConfiguration": {
                  "Cpu": "1024",
                  "Memory": "2048"
                }
              }
              EOF
                aws apprunner create-service --cli-input-json file://create-service.json --region $(awsRegion)
                echo "Service ${SERVICE_NAME} created."
              fi
            displayName: 'Create or update App Runner service (Staging/Beta)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

- stage: Prod
  displayName: 'Deploy to Prod'
  dependsOn: Staging
  condition: succeeded()
  jobs:
  - deployment: DeployToProd
    displayName: 'Deploy to Prod'
    environment: 'prod'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - script: |
              sudo apt-get update
              sudo apt-get install -y jq unzip
              # Install/Update AWS CLI v2
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install --update
            displayName: 'Install AWS CLI and jq'

          - script: |
              set -e
              SERVICE_NAME="$(appRunnerServiceNameProd)"
              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              IMAGE=${ACCOUNT_ID}.dkr.ecr.$(awsRegion).amazonaws.com/$(ecrRepoName):$(imageTag)
              PARAMS_FILE="Deployment/Transforms/Prod/parameters.json"
              ENV_ARR=$(jq -c 'to_entries | map({name: .key, value: ( .value|tostring)})' "${PARAMS_FILE}")
              ENV_ARR=$(jq -c --arg port "$(containerPort)" '. + [{"name":"ASPNETCORE_URLS","value":"http://+:" + $port}]' <<< "$ENV_ARR")
              
              # Get IAM role ARN
              ROLE_ARN=$(aws iam get-role --role-name $(appRunnerAccessRoleName) --query 'Role.Arn' --output text)
              
              # Check if service exists
              if aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text | grep -q .; then
                echo "App Runner service ${SERVICE_NAME} exists. Updating..."
                SERVICE_ARN=$(aws apprunner list-services --region $(awsRegion) --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn" --output text)
                cat > source-config.json <<EOF
              {
                "ImageRepository": {
                  "ImageIdentifier": "${IMAGE}",
                  "ImageRepositoryType": "ECR",
                  "ImageConfiguration": {
                    "Port": "$(containerPort)",
                    "RuntimeEnvironmentVariables": $ENV_ARR
                  }
                },
                "AuthenticationConfiguration": {
                  "AccessRoleArn": "${ROLE_ARN}"
                }
              }
              EOF
                aws apprunner update-service --service-arn ${SERVICE_ARN} --source-configuration file://source-config.json
              else
                echo "App Runner service ${SERVICE_NAME} does not exist. Creating..."
                cat > create-service.json <<EOF
              {
                "ServiceName": "${SERVICE_NAME}",
                "SourceConfiguration": {
                  "ImageRepository": {
                    "ImageIdentifier": "${IMAGE}",
                    "ImageRepositoryType": "ECR",
                    "ImageConfiguration": {
                      "Port": "$(containerPort)",
                      "RuntimeEnvironmentVariables": $ENV_ARR
                    }
                  },
                  "AuthenticationConfiguration": {
                    "AccessRoleArn": "${ROLE_ARN}"
                  },
                  "AutoDeploymentsEnabled": false
                },
                "InstanceConfiguration": {
                  "Cpu": "1024",
                  "Memory": "2048"
                }
              }
              EOF
                aws apprunner create-service --cli-input-json file://create-service.json --region $(awsRegion)
                echo "Service ${SERVICE_NAME} created."
              fi
            displayName: 'Create or update App Runner service (Prod)'
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

# Notes:
# - Set pipeline variables or variable group secrets for AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Do not commit secrets.
# - The pipeline will automatically create:
#   * ECR repository (paymentprocessor-api)
#   * IAM role for App Runner ECR access (AppRunnerECRAccessRole)
#   * App Runner services per environment (paymentprocessor-dev, paymentprocessor-qa, paymentprocessor-staging, paymentprocessor-prod)
# - On first run, services will be created. On subsequent runs, services will be updated with the new image.
# - This pipeline builds a Docker image from PaymentProcessor.Api/Dockerfile, pushes to ECR, and deploys to App Runner.
# - Ensure the Azure DevOps agent has permissions to run Docker (ubuntu-latest hosted agent is used).
